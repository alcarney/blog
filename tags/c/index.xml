<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c on Alex Carney</title>
    <link>https://www.alcarney.me/tags/c/</link>
    <description>Recent content in c on Alex Carney</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.alcarney.me/tags/c/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Creating a CPython Extension</title>
      <link>https://www.alcarney.me/blog/2021/ast-python-frontend/</link>
      <pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.alcarney.me/blog/2021/ast-python-frontend/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.alcarney.me/blog/2020/ast-simple-eval/&#34;&gt;Previously&lt;/a&gt;, as part of my exploration
into how programming languages are implemented, I wrote a very simple AST
evaluator that knew how to add and multiply floats together. Since constructing
these ASTs by hand is quite painful I thought it would be fun to come up with a
frontend to my &amp;ldquo;programming language&amp;rdquo; which could do it for me.&lt;/p&gt;
&lt;p&gt;Now your typical frontend would be some kind of parser built into the
compiler/interpreter. However, while I&amp;rsquo;m definitely interested in parsing I
don&amp;rsquo;t quite feel like tackling that just yet. Instead I&amp;rsquo;m going to have Python
be the frontend and embed my toy language into it via a &lt;a href=&#34;https://docs.python.org/3/extending/extending.html&#34;&gt;CPython
Extension&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Evaluating a Simple Abstract Syntax Tree</title>
      <link>https://www.alcarney.me/blog/2020/ast-simple-eval/</link>
      <pubDate>Sun, 27 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.alcarney.me/blog/2020/ast-simple-eval/</guid>
      <description>&lt;p&gt;Programming languages and their implementation is a topic I&amp;rsquo;ve been interested
in for a long time and I thought it would be worth trying to get a bit more
hands on and play with some of the ideas in this space. Choosing a topic
somewhat at random I&amp;rsquo;ve chosen to take a look at implementing an Abstract Syntax
Tree (AST).&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Learning Vulkan: Enumerating Physical Devices</title>
      <link>https://www.alcarney.me/blog/2020/learning-vulkan-p1/</link>
      <pubDate>Wed, 08 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.alcarney.me/blog/2020/learning-vulkan-p1/</guid>
      <description>&lt;p&gt;Being an API for talking to GPUs and other compute devices every Vulkan
program starts off by looking for an appropriate &lt;a href=&#34;https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/VkPhysicalDevice.html&#34;&gt;physical device&lt;/a&gt;
to use. In this post I write a little C program that initialises the Vulkan
API and lists out the available devices in the system.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;$ vkdevice
Device Name:            Intel(R) HD Graphics 520 (Skylake GT2)
  Type:                 Integrated GPU
  Vendor ID:            32902
  Device ID:            6422
  API Version:          v1.1.102
  Driver Version:       v19.3.1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Learning Vulkan: Overview</title>
      <link>https://www.alcarney.me/blog/2020/learning-vulkan-p0/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.alcarney.me/blog/2020/learning-vulkan-p0/</guid>
      <description>&lt;p&gt;I have always been interested in graphics and have on numerous occasions tried
to dip my toe into the world of OpenGL and more recently Vulkan. However I have
never been able to get past the &amp;ldquo;Hello, World&amp;rdquo; of these technologies - drawing a
triangle on screen, I think mostly becuase I never really had a goal in mind
once I got that far&amp;hellip;&lt;/p&gt;
&lt;p&gt;But that&amp;rsquo;s (hopefully) about to change! What better excuse than a new decade to
jump back into this world for the 100th time and try to get to all those
interesting ideas I see people playing with all the time!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ccalc</title>
      <link>https://www.alcarney.me/code/ccalc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.alcarney.me/code/ccalc/</guid>
      <description>A CPython extension that embeds the simple-ast program into Python.
&amp;gt;&amp;gt;&amp;gt; import ccalc &amp;gt;&amp;gt;&amp;gt; expression = (ccalc.Literal(1) + 2) * 3 &amp;gt;&amp;gt;&amp;gt; expression Multiply&amp;lt;Plus&amp;lt;Literal&amp;lt;1.0&amp;gt;, Literal&amp;lt;2.0&amp;gt;&amp;gt;, Literal&amp;lt;3.0&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; ccalc.eval_ast(expression) 9.0 Building It&amp;rsquo;s probably worth creating a virtual environment to work in
 .cli-command::before { content: &#34;$ &#34;; }    python -m venv .env   Assuming you have a C compiler available, building the extension is as easy as running the following command</description>
    </item>
    
    <item>
      <title>Simple AST</title>
      <link>https://www.alcarney.me/code/simple-ast/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.alcarney.me/code/simple-ast/</guid>
      <description>A simple C program that can construct and evaluate a simple Abstract Syntax Tree (AST). The AST represents a toy &amp;ldquo;programming language&amp;rdquo; that only knows how to add and multiply floating point numbers together.
$ ./simple-ast * + 1.00 2.00 3.00 Example 1: 9.00 + 1.00 * 2.00 3.00 Example 2: 7.00 Building Having no real dependencies beyond the standard library this program can be compiled with just a C compiler</description>
    </item>
    
    <item>
      <title>Writing Makefiles</title>
      <link>https://www.alcarney.me/notes/writing-makefiles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.alcarney.me/notes/writing-makefiles/</guid>
      <description>Pattern Rules A pattern rule can be used to define a generic recipe for turning a file of type X into a file a type Y for example, compiling program.c into program.o. A pattern rule can be defined as follows
%.o: %.c $(CC) -c $(CFLAGS) $&amp;lt; -o $@  %.o/%.c Will match files of the form *.o and *.c respectively $&amp;lt; can be used to reference all the dependencies of the target, in this case the *.</description>
    </item>
    
  </channel>
</rss>
