<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on Alex Carney</title>
    <link>https://www.alcarney.me/tags/python/</link>
    <description>Recent content in python on Alex Carney</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.alcarney.me/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Creating a CPython Extension</title>
      <link>https://www.alcarney.me/blog/2021/ast-python-frontend/</link>
      <pubDate>Wed, 13 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.alcarney.me/blog/2021/ast-python-frontend/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.alcarney.me/blog/2020/ast-simple-eval/&#34;&gt;Previously&lt;/a&gt;, as part of my exploration
into how programming languages are implemented, I wrote a very simple AST
evaluator that knew how to add and multiply floats together. Since constructing
these ASTs by hand is quite painful I thought it would be fun to come up with a
frontend to my &amp;ldquo;programming language&amp;rdquo; which could do it for me.&lt;/p&gt;
&lt;p&gt;Now your typical frontend would be some kind of parser built into the
compiler/interpreter. However, while I&amp;rsquo;m definitely interested in parsing I
don&amp;rsquo;t quite feel like tackling that just yet. Instead I&amp;rsquo;m going to have Python
be the frontend and embed my toy language into it via a &lt;a href=&#34;https://docs.python.org/3/extending/extending.html&#34;&gt;CPython
Extension&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>TIL: Python has a cmd module</title>
      <link>https://www.alcarney.me/blog/2019/til-python-cmd/</link>
      <pubDate>Sat, 05 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.alcarney.me/blog/2019/til-python-cmd/</guid>
      <description>&lt;p&gt;Today I Learned that Python&amp;rsquo;s standard library has a &lt;a href=&#34;https://docs.python.org/3/library/cmd.html&#34;&gt;cmd&lt;/a&gt; module and it is &lt;em&gt;awesome!&lt;/em&gt;&lt;/p&gt;
&lt;figure&gt;&lt;a href=&#34;https://www.alcarney.me/images/cmd_python.gif&#34;&gt;
    &lt;img src=&#34;https://www.alcarney.me/images/cmd_python.gif&#34;
         alt=&#34;Interactive program using the cmd module.&#34;/&gt; &lt;/a&gt;&lt;figcaption&gt;
            &lt;p&gt;Interactive program using the cmd module.&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;</description>
    </item>
    
    <item>
      <title>Introducing Stylo Doodles!</title>
      <link>https://www.alcarney.me/blog/2018/introducing-stylo-doodles/</link>
      <pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.alcarney.me/blog/2018/introducing-stylo-doodles/</guid>
      <description>&lt;p&gt;A few weeks back at &lt;a href=&#34;https://2018.pyconuk.org/&#34;&gt;PyConUK&lt;/a&gt; I gave my first &lt;a href=&#34;https://youtu.be/F5jSUJVymXk?t=3480&#34;&gt;lighting talk&lt;/a&gt;
at a conference. During that talk I spoke publically about &lt;a href=&#34;https://github.com/alcarney/stylo&#34;&gt;stylo&lt;/a&gt; for
the first time. Stylo is a Python library that I have been working on for just
over a year and a half and it aims to make the creation of images easier by
bringing together ideas from programming and mathematics.&lt;/p&gt;
&lt;p&gt;Version &lt;a href=&#34;https://alcarney.github.io/stylo/changes.html&#34;&gt;0.6.0&lt;/a&gt; was recently released which included the first feature
that wasn&amp;rsquo;t written by me! It&amp;rsquo;s very exciting not only to see other people
starting to take an interest in the project but taking the time to make a
contribution!&lt;/p&gt;
&lt;p&gt;Now that stylo seems to be getting to the point that it might me useful to
other people wouldn&amp;rsquo;t it be great if there was a community driven example
gallery that people could get inspired by? - Well now there is! And it&amp;rsquo;s
called &lt;a href=&#34;https://alcarney.github.io/stylo-doodles&#34;&gt;Stylo Doodles&lt;/a&gt;&lt;/p&gt;
&lt;figure&gt;&lt;a href=&#34;https://www.alcarney.me/images/stylo-doodles.png&#34;&gt;
    &lt;img src=&#34;https://www.alcarney.me/images/stylo-doodles.png&#34;/&gt; &lt;/a&gt;
&lt;/figure&gt;</description>
    </item>
    
    <item>
      <title>ccalc</title>
      <link>https://www.alcarney.me/code/ccalc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.alcarney.me/code/ccalc/</guid>
      <description>A CPython extension that embeds the simple-ast program into Python.
&amp;gt;&amp;gt;&amp;gt; import ccalc &amp;gt;&amp;gt;&amp;gt; expression = (ccalc.Literal(1) + 2) * 3 &amp;gt;&amp;gt;&amp;gt; expression Multiply&amp;lt;Plus&amp;lt;Literal&amp;lt;1.0&amp;gt;, Literal&amp;lt;2.0&amp;gt;&amp;gt;, Literal&amp;lt;3.0&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; ccalc.eval_ast(expression) 9.0 Building It&amp;rsquo;s probably worth creating a virtual environment to work in
 .cli-command::before { content: &#34;$ &#34;; }    python -m venv .env   Assuming you have a C compiler available, building the extension is as easy as running the following command</description>
    </item>
    
    <item>
      <title>Custom Jupyter Kernels</title>
      <link>https://www.alcarney.me/notes/custom-jupyter-kernels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.alcarney.me/notes/custom-jupyter-kernels/</guid>
      <description>It&amp;rsquo;s possible to create custom Python environments for use within a Jupyter notebook without having to run a jupyter server from each of them. The following steps will allow you to have a single jupyter server running and have it use a variety of Python environments in its notebooks
 Create a virtualenv and install any packages that you want available pip install ipykernel ipykernel install --user --name &amp;lt;envname&amp;gt; --display-name &amp;lt;display name&amp;gt;  Then the new environment should become available in the Change kernel menu</description>
    </item>
    
    <item>
      <title>Python 2.x Gotchas</title>
      <link>https://www.alcarney.me/notes/python-2-gotchas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.alcarney.me/notes/python-2-gotchas/</guid>
      <description>While at the time of writing (May 2019) the death of Python 2 is just around the corner since I&amp;rsquo;m working in an enterprise environment I&amp;rsquo;m sure I will be dealing with Python 2.x code for some time to come. To that end here are some gotchas to keep in mind.
Missing Features In the 10+ years since Python 3&amp;rsquo;s release it&amp;rsquo;s not surprising that it has accumlated a large list of features that simply don&amp;rsquo;t exist in Python 2.</description>
    </item>
    
    <item>
      <title>Python 3.x Gotchas</title>
      <link>https://www.alcarney.me/notes/python-3-gotchas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.alcarney.me/notes/python-3-gotchas/</guid>
      <description>Beware pathlib on 3.5 While pathlib exists in Python 3.5, it&amp;rsquo;s not fully integrated yet. Passing a pathlib.Path object to the built-in open method will result in a surprising error
TypeError: invalid file: PosixPath(&amp;#39;path/to/file.txt&amp;#39;) In this situation it&amp;rsquo;s better to call the path&amp;rsquo;s open() method instead.</description>
    </item>
    
  </channel>
</rss>
