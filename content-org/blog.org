#+HUGO_BASE_DIR: ../
#+HUGO_SECTION: ./blog/
#+HUGO_CODE_FENCE: nil
#+STARTUP: logdone

* TODO Post on Sphinx referencing
* TODO Post on python namespace packages
* TODO Post on python entry points.
* TODO Post on optimising caching format for stylo             :python:stylo:

Encoding/decoding boolean masks as integer arrays in HDF5 files.

* TODO Creating an Infinite Scaleable Grid                       :js:web:svg:
:PROPERTIES:
:EXPORT_FILE_NAME: svg-scaling-grid
:END:

#+BEGIN_EXPORT html
<figure>
  <div id="main"></div>
  <figcaption>
    <p>A pannable, zoomable grid</p>
  </figcaption>
</figure>
<script type="text/javascript" src="/js/grid-scale.js"></script>
#+END_EXPORT

#+NAME: draw-line
#+BEGIN_SRC javascript
function makeLine(a, b) {

   const line = document.createElementNS(svgns, "line")

   line.setAttribute("x1", a.x)
   line.setAttribute("x2", b.x)
   line.setAttribute("y1", a.y)
   line.setAttribute("y2", b.y)

   line.setAttribute("stroke", "white")
   line.setAttribute("stroke-opacity", 0.5)
   line.setAttribute("stroke-width", 0.2)

   return line
}
#+END_SRC

#+NAME: draw-grid
#+BEGIN_SRC javascript
function drawGrid(canvas, viewBox, spacing) {

  const numRows = Math.ceil(viewBox.height / spacing)
  const numCols = Math.ceil(viewBox.width / spacing)

  for (let i = 0; i < numRows; i++) {

     const y = (i * spacing) + (spacing / 2)
     const line = makeLine({x: viewBox.xMin, y: y}, {x: viewBox.width, y: y})
     canvas.appendChild(line)
  }

  for (let i = 0; i < numCols; i++) {

    const x = (i * spacing) + (spacing / 2)
    const line = makeLine({x: x, y: viewBox.yMin}, {x: x, y: viewBox.height})
    canvas.appendChild(line)
  }
}
#+END_SRC

#+BEGIN_SRC javascript :noweb yes :tangle ../static/js/grid-scale.js
const svgns = "http://www.w3.org/2000/svg"

<<draw-line>>

<<draw-grid>>

const main = document.getElementById("main");
main.style.height = "300px"

const canvas = document.createElementNS(svgns, "svg")
canvas.setAttribute("width", "100%")
canvas.setAttribute("height", "100%")
canvas.setAttribute("preserveAspectRatio", "xMidYMid slice")
canvas.style.border = "solid 2px #242930"

main.appendChild(canvas)

const bbox = canvas.getBoundingClientRect()
const scale = 100;
const aspectRatio = bbox.width / bbox.height

const viewBox = {xMin: 0, yMin: 0, width: scale * aspectRatio, height: scale}
const viewBoxStr = [
  viewBox.xMin, viewBox.yMin, viewBox.width, viewBox.height
].join(" ")

canvas.setAttribute("viewBox", viewBoxStr)
drawGrid(canvas, viewBox, 20)
#+END_SRC

* DONE Implementing Click & Drag with Vanilla JS                 :svg:web:js:
CLOSED: [2019-07-07 Sun 21:24]
:PROPERTIES:
:EXPORT_FILE_NAME: click-drag-vanilla-js
:END:

#+BEGIN_EXPORT html
<figure>
  <div id="main"></div>
  <figcaption>
    <p>Try clicking and dragging on this circle.</p>
  </figcaption>
</figure>
<script type="text/javascript" src="/js/click-drag.js"></script>
#+END_EXPORT

#+BEGIN_QUOTE
*Disclaimer:*

This post makes use of a number of interactive elements to help illustrate a few
concepts. Unfortunately these do not yet work on mobile devices - sorry mobile
users!
#+END_QUOTE

I have for quite some time now wanted to play around with web development some
more, particularly using web technologies to build user interfaces of some
kind. However there is just *so much* out there it's been impossible for me to
really get anywhere past a "Hello, World!" tutorial before I find myself trying
out the next new shiny.

So I've decided to abandon everything and try a bottom up approach where I see
how far I can push the core web technologies - HTML, CSS and
JavaScript. Hopefully then by the time I start using one of the gazillion
libraries out there I will have a better understanding of why I
needed it in the first place.

In this post I will be looking at implementing clicking and dragging
functionality using only vanilla JavaScript. Clicking and dragging as a concept
can apply to many kinds of interactions so in this instance I'm specifically
referring to clicking on an SVG element moving it around on the page as
illustrated by the demo above.

#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT

** Setup

All we need to get started is a HTML document that contains some markup which
provides someplace we can reference and attach our image element to, as well as
loading the code we write.

#+BEGIN_SRC html
<div id="main"></div>
<script type="text/javascript" src="./click-drag.js"></script>
#+END_SRC

Then the first step is to create our SVG image element to act as our "canvas"
that we can draw on.

#+NAME: create-canvas
#+BEGIN_SRC javascript
const svgns = "http://www.w3.org/2000/svg"
const main = document.getElementById("main")

const canvas = document.createElementNS(svgns, "svg")
canvas.setAttribute("width", "100%")
canvas.setAttribute("height", "100%")
canvas.style.border = "solid 2px #242930"

main.appendChild(canvas)
#+END_SRC

A few things to note:
- By adding our ~<svg>~ element as a child of some ~<div>~ element and setting
  both the ~width~ and ~height~ to ~100%~ our canvas will be able to
  scale responsively based on the styles applied to the parent ~<div>~
- You might already be familiar with the [[https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement][~document.createElement()~]] function for
  creating HTML elements using JavaScript. However in order to work with SVG
  elements we need to use the [[https://developer.mozilla.org/en-US/docs/Web/API/Document/createElementNS][~document.createElementNS()~]] function which allows
  us to use the SVG namespace instead of the HTML default.

** The View Box

The next step is to construct an appropriate ~viewBox~ definition for our
canvas. For more information on the ~viewBox~ you can refer to the [[https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/viewBox][documentation]]
but to briefly summarise. An SVG image exists on an infinite plane and the
~viewBox~ is the window we use to view a portion of that space, changing the
definition of the ~viewBox~ allows you to zoom in and out on particular regions.

For our purposes what's important is that we construct a ~viewBox~ that matches
the proportions of the ~<svg>~ element as it is displayed in the browser. If
these proportions do not match then the element being dragged around will not
accurately track the cursor, either racing away from or lagging behind it.

One minor issue is that in our setup we didn't explicitly set the dimensions of
our ~<svg>~ element - so how can we know its proportions? Thankfully once the
~<svg>~ as been added to the page we can ask the browser for the bounding box
around the element.

#+NAME: set-viewbox
#+BEGIN_SRC javascript
let bbox = canvas.getBoundingClientRect()
#+END_SRC

Among other properties that are outlined on [[https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect][this]] page we can get the width and
height of the rendered image in pixels from which its easy to calculate the
aspect ratio.

#+NAME: set-viewbox
#+BEGIN_SRC javascript
const aspectRatio = bbox.width / bbox.height
#+END_SRC

We're free to choose whichever scale we want for the vertical height of the
~viewBox~ into the ~<svg>~ element. I have chosen ~100~ simply because it feels
like a nice round number. Once we've decided on a scale for the height, it's
easy enough to calculate the corresponding width from our aspect ratio.

#+NAME: set-viewbox
#+BEGIN_SRC javascript
const height = 100
const width = height * aspectRatio
#+END_SRC

With the dimensions of the ~viewBox~ taken care of all that is left to do is
decide on the coordinates to assign to the top left corner of the ~<svg>~
element and assign the view box to our canvas.

#+NAME: set-viewbox
#+BEGIN_SRC javascript
const viewBox = {minX: 0, minY: 0, width: width, height: height}

const viewBoxStr = [
  viewBox.minX, viewBox.minY, viewBox.width, viewBox.height
].join(" ")

canvas.setAttribute("viewBox", viewBoxStr)
#+END_SRC

** Something to Click on

By this point we have finished preparing our canvas and it's time to add
something for us to interact with. To keep things simple I will stick to a ~<circle>~
element, though the method we use here should apply to any SVG element (or any
collection of elements under a ~<g>~ tag).

#+NAME: add-circle
#+BEGIN_SRC javascript
const circle = document.createElementNS(svgns, "circle")
circle.setAttribute("cx", viewBox.width / 2)
circle.setAttribute("cy", viewBox.height / 2)
circle.setAttribute("r", 15)
circle.setAttribute("fill", "#57cc8a")

canvas.appendChild(circle)
#+END_SRC

#+BEGIN_QUOTE
*Note:*

Of course the way in which you define the position of your interactive element
will depend on the element you have chosen.
#+END_QUOTE

** Implementing the Drag

We will create an event handler for the ~mousemove~ event and attach it to
our canvas.

#+BEGIN_SRC javascript
canvas.addEventListener("mousemove", (event) => {
  // Do something clever here...
})
#+END_SRC

The function we write will be called every time the cursor moves regardless of
whether the user has clicked or not. This means our event handler has to be able
to cope with two situations, the cursor moving when the user has clicked and the
cursor moving when the user has not clicked.

To do this we will declare a variable called ~clicked~ outside the scope of our
function.

#+NAME: dragging
#+BEGIN_SRC javascript
let clicked = false
#+END_SRC

For the moment we will ignore the details around how this variable is updated
(it is covered in the next section), instead let's focus on what we do while the
cursor is moving about the page

Let's get the simpler case out of the way first

*** Not Clicked

When the mouse is moving but the user has not clicked, then there is nothing for
us to do! We can simply check the value of the ~clicked~ variable and stop the
function if it meets the criteria.

#+BEGIN_SRC javascript
if (!clicked) {
  return
}
#+END_SRC

*** Clicked

Now for the interesting part! The mouse is moving and the user has clicked on
the circle, all we have to do now is update its position to match
the cursor's current position. The only problem is... where is it?

Like all mouse related events the ~event~ object passed into the event handler
will contain a number of position related properties.

- ~e.client<XY>~: Coordinates of the cursor with respect to the current portion
  of the document visible on the page.
- ~e.offset<XY>~: Coordinates of the cursor with respect to the edge of the
  target element
- ~e.page<XY>~: Coordinates of the cursor with respect to the entire HTML page,
  including any portions of the page not currently visible
- ~e.screen<XY>~: Coordinates of the cursor with respect to the user's display

Reading through those descriptions you would imagine that the ~e.offset<XY>~
properties would be the best fit for our use case. However it's not quite as
simple as that.

Below you should see 2 boxes, the bigger one on the left is our canvas. The
smaller box on the right contains a smaller circle that represents the
calculated position of the cursor based on the ~offset<XY>~ properties like so.

#+BEGIN_SRC javascript
const x = event.offsetX
const y = event.offsetY
#+END_SRC

Try moving the mouse across the canvas and keep an eye on the calculated
position.

#+BEGIN_EXPORT html
<figure>
  <div id="offset-demo"
       style="display:grid;grid-template-columns:50% auto;grid-gap:10px">
  <h3 id="offset-title" style="margin: 0; padding: 15px; padding-top: 0">
    Cursor Position: Offset
  </h3>
    <div>
      <p style="margin:0;padding-left:20px">Target: <span id="offset-target"></span></p>
      <p style="margin:0;padding-left:20px">Position: <span id="offset-position"></span></p>
    </div>
    <svg width="100%"
         id="offset-demo-canvas"
         style="border: solid 2px #242930">
    </svg>
    <svg width="50%"
         id="offset-posbox"
         style="border: solid 2px #242930;margin:auto"><svg>
  </div>
  <figcaption>
    <p>
      Determining the cursor's position using the <code>event.offsetX</code> and
      <code>event.offsetY</code> properties
    </p>
  </figcaption>
</figure>
<script type="text/javascript" src="./js/click-drag-offset.js"></script>
#+END_EXPORT

Notice the issue when we move across the circle? Why does the calculated
position of the cursor suddenly jump whenever we touch it? The answer lies in
the description of the ~offset<XY>~ property "with respect to the edge of the
*target* element"

When initially trying to implement this I incorrectly assumed that the target
element meant the element that we attached the event listener to - the canvas. In
fact the target element is whichever element is currently under the cursor

To work around this we can calculate the offset values we need ourselves. In
order to do this we will make use of both the bounding box returned from the
~canvas.getBoundingClientRect()~ method as well as the ~client<XY>~ properties
found on the mouse event.

It turns out that the bounding box also returns the coordinates of the top left
corner of the canvas relative to the user's current view of the document -
exactly the same coordinate system used by the ~client<XY>~ properties! From
those two pieces of information it's easy enough to recover the ~offset<XY>~
values ourselves.

#+BEGIN_SRC javascript
bbox = canvas.getBoundingClientRect()

const x = event.clientX - bbox.left
const y = event.clientY - bbox.top
#+END_SRC

By calculating the coordinates using values that are independent of the element
currently underneath the cursor we sidestep any issues that arise from a
changing target. Try the same thing again on the canvas below.

#+BEGIN_EXPORT html
<figure>
  <div id="client-demo"
       style="display:grid;grid-template-columns:50% auto;grid-gap:10px">
    <h3 id="offset-title" style="margin: 0; padding: 15px; padding-top: 0">
      Cursor Position: Client
    </h3>
    <div>
      <p style="margin:0;padding-left:20px">Target: <span id="client-target"></span></p>
      <p style="margin:0;padding-left:20px">Position: <span id="client-position"></span></p>
    </div>
    <svg width="100%"
         id="client-demo-canvas"
         style="border: solid 2px #242930">
    </svg>
      <svg width="50%"
           id="client-posbox"
           style="border: solid 2px #242930;margin:auto"><svg>
  </div>
  <figcaption>
    <p>
      Determining the cursor's position using the <code>event.clientX</code> and
      <code>event.clientY</code> properties
    </p>
  </figcaption>
</figure>
<script type="text/javascript" src="./js/click-drag-client.js"></script>
#+END_EXPORT

#+BEGIN_QUOTE
*Important:*

Since the values ~bbox.top~ and ~bbox.left~ are defined relative to the user's
current view on the document these values are *not* constant. They will change
whenever the user alters their view of the page, i.e. performing actions like
resizing the window or scrolling. This is why we ask for an updated bounding box
every time our event handler is called.
#+END_QUOTE

Now that we can reliably know the position of the cursor, we can focus on the
final piece of this puzzle - updating the position of our ~<circle>~
element. There is however one further issue to work through. The position of the
cursor that we've just calculated is using a different coordinate system to the
one used to draw our circle!

Although we have managed to correctly calculate the cursor's position relative
to our canvas, that position is measured using pixels which makes it highly
dependent on the resolution of the user's screen. A user who uses a 4K monitor
and positions their cursor at the bottom right of the canvas will have a
calculated position much larger than a user on a smartphone...

What this means is that if we map this calculated position directly onto the
circle it won't accurately follow the cursor. The only time the circle would
follow the cursor correctly is when the pixel based coordinates line up with the
coordinate system used in the SVG image. I.e. when the dimensions of the canvas
match up *exactly* with the scale used to define our ~viewBox~ which in this
case would be ~100px~ tall

Since the mouse circle and the circle use different coordinate systems, we don't
actually care about the exact position we have just calculated. What's more
important is the position of the cursor relative to bounds of the canvas - a
percentage. For example, let's say that the cursor was halfway down the canvas
(~50%~) then we could calculate the corresponding coordinate value in the SVG
coordinate system by multiplying the total height by ~50%~. In our particular
case this would mean setting ~y = 100 * 0.5 = 50~.

We can adopt this approach by using the ~width~ and ~height~ information
returned as part of the bounding box to modify our calculation to produce a
percentage rather than an absolute value.

#+BEGIN_SRC javascript
const x = (event.clientX - bbox.left) / bbox.width
const y = (event.clientY - bbox.top) / bbox.height
#+END_SRC

To then convert this percentage into its corresponding value in the SVG
coordinate system all we have to do is multiply it by the width and height of
that system and assign the result to our circle's position!

#+BEGIN_SRC javascript
circle.setAttriubte("cx", x * viewBox.width)
circle.setAttribute("cy", y * viewBox.height)
#+END_SRC

Bringing all that together we end up with the following implementation of our
~mousemove~ event handler.

#+NAME: dragging
#+BEGIN_SRC javascript
canvas.addEventListener("mousemove", (event) => {

  if (!clicked) {
    return
  }

  bbox = canvas.getBoundingClientRect()

  const x = (event.clientX - bbox.left) / bbox.width
  const y = (event.clientY - bbox.top) / bbox.height

  circle.setAttribute("cx", x * viewBox.width)
  circle.setAttribute("cy", y * viewBox.height)
})
#+END_SRC

Nearly there! The only thing left to do is decide on how we want to update the
~clicked~ variable.

** Click Detection

Finally all that's left is to do is decide how we want to toggle the dragging
behaviour. This mostly comes down to how you want the user to interact with the
draggable object and will change depending on your use case. To keep things
simple I will go with a fairly simple interaction model

- If the mouse is over the circle and the user clicks then start dragging
- If the user releases the mouse button then stop dragging

#+NAME: clicking
#+BEGIN_SRC javascript
circle.addEventListener("mousedown",  (_) => { clicked = true })
circle.addEventListener("mouseup", (_) => { clicked = false })
#+END_SRC


Additionally I will impose one final condition
- If the mouse leaves the bounds of the canvas then stop dragging.

#+NAME: clicking
#+BEGIN_SRC javascript
canvas.addEventListener("mouseleave", (_) => { clicked = false })
#+END_SRC

This last point is to work around an issue that arises when the user moves the
cursor out of the bounds of the canvas and releases the mouse button. Since the
cursor is no longer over the circle the handler for the ~mouseup~ event on the
circle is never fired so when the user brings their cursor back over the canvas
our code still believes the user never released the mouse button and so the
circle will appear "stuck" to their cursor until they click again.

** Conclusion

There you have it, those were some of the basics required to get a working proof
of concept of clicking and dragging functionality using only the JavaScript APIs
that come with your web browser. However in writing this blog post I realised
as with anything that the rabbit hole goes deep and there are many
considerations to keep in mind if you wanted to "productionise" this code for
any real usage.

- *Touchscreen Support*

  If you were reading this post on a mobile device you will already have noticed
  that none of the interactive demos have worked. This is because touchscreens
  have their own family of ~touchXXXX~ events that are triggered when a user
  interacts with a webpage. While there is some mouse emulation done by the
  browsers (e.g. a ~touchstart~ event will trigger a ~mousedown~ event if not
  handled), some key events such as ~mousemove~ are not emulated and require
  dedicated support in your code. See [[https://www.html5rocks.com/en/mobile/touch/][these]] [[https://www.html5rocks.com/en/mobile/touchandmouse/][articles]] for more details

- *Snap to Center*

  This is only a minor issue and depending on your use case may not be a problem
  at all. Currently whenever you pick up the circle its center snaps to the
  cursor's position. There may be situations where you would prefer the keep the
  object's relative position to the cursor e.g. fine adjustments, the last thing
  you would want is for the object to jump to the cursor just because the user
  happened to click on it off center.

  A way around this would be to record the original positions of both the mouse
  cursor and the object on a click, then on each ~mousemove~ event calculate the
  distance moved by the cursor and apply it to the original recorded position of
  the object.

- *Multiple Objects*

  Chances are when using this functionality in a real application you would want
  the ability to click and drag on multiple objects. Adding support for this
  would require reworking at least some of the code, having the canvas object
  handle all mouse movements is probably a good idea but of course updating the
  circle's position directly would have to change. It would probably make sense
  to move the click detection logic onto the canvas also, making use of the
  ~event.target~ property to determine which object would need updating.

- *Canvas Resizing*

  While the existing code makes some effort to ensure this works in a responsive
  manner it is currently only "statically responsive". What I mean is that on
  page load all the necessary calculations are performed to ensure that the
  ~viewBox~ has the correct proportions for example. However if the user were to
  resize the webpage, or rotate their device chances are the proportions of the
  canvas would change meaning that the circle would no longer follow the cursor
  correctly.

  In order to be truly responsive, we would need to listen for events such as
  [[https://developer.mozilla.org/en-US/docs/Web/API/Window/resize_event][resize]] and perform all the calculations again.

- *Pan and Zoom*

  Something I realised when writing up the part where we map the cursor's
  position onto the position of the circle is that I had by chance chosen a
  special case where the maths is a little easier. The calculations ~x *
  viewBox.width~ and ~y * viewBox.height~ only work because our ~viewBox~ starts
  at ~(0, 0)~.

  Say we had an application that also allowed for panning and zooming of the
  canvas itself then the chances are our ~viewBox~ would not be starting at ~(0,
  0)~ and we would have to include an offset in our calculations to reflect
  this. This means for the general case our code should probably look something
  like this

  #+BEGIN_SRC javascript
  circle.setAttribute("cx", (x * viewBox.width) - viewBox.minX)
  circle.setAttribute("cy", (y * viewBox.height) - viewBox.minY)
  #+END_SRC

I'm sure there are more edge cases and considerations to think of but this post
is long enough already! - Perhaps this is why people use libraries for this kind
of thing 🤔...

I will leave you with the final version of the code that went into the demo you
saw at the start of this blog post so you can see it all in context. Hopefully
you found this useful and I'll see you in the next one!

#+BEGIN_SRC javascript :noweb yes :tangle ../static/js/click-drag.js
// Setup
<<create-canvas>>

// Viewbox
<<set-viewbox>>

// Something to click on
<<add-circle>>

// Implementing the drag
<<dragging>>

// Click detection
<<clicking>>
#+END_SRC
#+BEGIN_SRC javascript :exports none :tangle ../static/js/click-drag-offset.js
  function offsetDemo() {

      const svgns = "http://www.w3.org/2000/svg"
      const canvas = document.getElementById("offset-demo-canvas")
      const target = document.getElementById("offset-target")
      const position = document.getElementById("offset-position")
      const posBox = document.getElementById("offset-posbox")
      posBox.setAttribute("viewBox", "0 0 1 1")

      let bbox = canvas.getBoundingClientRect()
      const aspectRatio = bbox.width / bbox.height

      const height = 100
      const width = aspectRatio * height

      const viewBox = {minX: 0, minY: 0, width: width, height: height}

      const viewBoxStr = [
          viewBox.minX, viewBox.minY, viewBox.width, viewBox.height
      ].join(" ")

      canvas.setAttribute("viewBox", viewBoxStr)

      const circle = document.createElementNS(svgns, "circle")
      circle.setAttribute("cx", viewBox.width / 2)
      circle.setAttribute("cy", viewBox.height / 2)
      circle.setAttribute("r", 25)
      circle.setAttribute("fill", "#57cc8a")

      canvas.appendChild(circle)

      const point = document.createElementNS(svgns, "circle")
      point.setAttribute("cx", 0)
      point.setAttribute("cy", 0)
      point.setAttribute("r", 0.05)
      point.setAttribute("fill", "#57cc8a")

      posBox.appendChild(point)

      canvas.addEventListener("mousemove", (event) => {

          const x = event.offsetX
          const y = event.offsetY

          bbox = canvas.getBoundingClientRect()

          const u = x / bbox.width
          const v = y / bbox.height

          position.innerText = "(" + x + "px, " + y + "px)"
          target.innerText = "<" + event.target.tagName + ">"

          point.setAttribute("cx", u)
          point.setAttribute("cy", v)
      })
  }

  offsetDemo()
#+END_SRC
#+BEGIN_SRC javascript :exports none :tangle ../static/js/click-drag-client.js
  function clientDemo() {
      const svgns = "http://www.w3.org/2000/svg"

      const canvas = document.getElementById("client-demo-canvas")
      const target = document.getElementById("client-target")
      const position = document.getElementById("client-position")
      const posBox = document.getElementById("client-posbox")
      posBox.setAttribute("viewBox", "0 0 1 1")

      let bbox = canvas.getBoundingClientRect()
      const aspectRatio = bbox.width / bbox.height

      const height = 100
      const width = aspectRatio * height

      const viewBox = {minX: 0, minY: 0, width: width, height: height}
      const viewBoxStr = [
          viewBox.minX, viewBox.minY, viewBox.width, viewBox.height
      ].join(" ")

      canvas.setAttribute("viewBox", viewBoxStr)

      const circle = document.createElementNS(svgns, "circle")
      circle.setAttribute("cx", viewBox.width / 2)
      circle.setAttribute("cy", viewBox.height / 2)
      circle.setAttribute("r", 25)
      circle.setAttribute("fill", "#57cc8a")

      canvas.appendChild(circle)

      const point = document.createElementNS(svgns, "circle")
      point.setAttribute("cx", 0)
      point.setAttribute("cy", 0)
      point.setAttribute("r", 0.05)
      point.setAttribute("fill", "#57cc8a")

      posBox.appendChild(point)

      canvas.addEventListener("mousemove", (event) => {

          bbox = canvas.getBoundingClientRect()

          const x = event.clientX - bbox.left
          const y = event.clientY - bbox.top

          position.innerText = `(${x.toFixed(0)}px, ${y.toFixed(0)}px)`
          target.innerText = `<${event.target.tagName}>`

          point.setAttribute("cx", x / bbox.width)
          point.setAttribute("cy", y / bbox.height)
      })

  }

  clientDemo()
#+END_SRC

* DONE TIL: Python has a ~cmd~ module                  :stylo:python:til:cli:
:PROPERTIES:
:EXPORT_DATE: 2019-01-05
:EXPORT_FILE_NAME: til-python-cmd
:EXPORT_DESCRIPTION: Today I learned about Pyton's cmd module
:END:

Today I Learned that Python's standard library has a [[https://docs.python.org/3/library/cmd.html][cmd]] module and it is /awesome!/

#+CAPTION: Interactive program using the cmd module.
[[/images/cmd_python.gif][file:/images/cmd_python.gif]]

#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT

The [[https://docs.python.org/3/library/cmd.html][cmd]] module contains a single class called ~Cmd~ which handles all the
details of creating an application similar to Python's REPL. All you need to do
is to provide some command definitions and the ~Cmd~ class will handle the rest.

In an attempt to demonstrate why I think this is so cool I'm going to walk
through the process of building the application you see in the screencast above.

The example application we're going to create is a very basic REPL for a passion
project of mine called [[https://github.com/alcarney/stylo][stylo]]. Stylo is a Python library that allows you to draw
images and create animations using code and some mathematics. The application
will expose some of the basic shapes available and for the "Print" part of the
[[https://en.wikipedia.org/wiki/Read%25E2%2580%2593eval%25E2%2580%2593print_loop][REPL]] it will show a preview of your image.

My main focus for this post is the ~cmd~ module which means I'm not going to go
into any of the specifics of ~stylo~ or how to use it. If you want to know more
about it I will point you in the direction of the [[https://stylo.readthedocs.io/][documentation]]
(under construction :construction:) and the [[https://alcarney.github.io/stylo-doodles][example gallery]]

** Setup

To start with we're going to create a virtual environment and install ~stylo~
into it. This will also install ~matplotlib~ which we will be using later on.
I'm using Python 3.7 but this application should work on all versions of Python
≥ 3.5.

#+BEGIN_SRC sh
$ python -m venv env
$ source env/bin/activate
(env) $ pip install stylo
#+END_SRC

*Note:* The ~cmd~ module is available for [[https://docs.python.org/2.7/library/cmd.html][even older]] versions of
Python. However we are limited by ~stylo~ which only supports Python 3.5+

With the dependencies out of the way we can create a file called ~stylo-cmd.py~
and start writing some code!

#+BEGIN_SRC python
import cmd

class StyloPrompt(cmd.Cmd):
    pass

if __name__ == '__main__':
    prompt = StyloPrompt()
    prompt.cmdloop()
#+END_SRC

This is the bare minimum required to get something we can start playing with.
If you were to run ~python stylo-cmd.py~ you would see the following prompt
which comes with a single built-in command ~help~.

#+BEGIN_SRC
(Cmd) help

Documented commands (type help <topic>):
========================================
help
#+END_SRC

~Ctrl-C~ will exit the application. Obviously this is pretty useless right now
so let's look at adding in some commands of our own.

**  Adding Commands

Any method on our ~StyloPrompt~ class with a name of the form ~do_*~ is
considered a command, with the command name given by whatever is after the
underscore.  To get ourselves warmed up let's add two commands ~reset~ and
~save~ which will allow us to create a fresh image and save it to a file.

#+BEGIN_SRC python
from stylo.image import LayeredImage

class StyloPrompt(cmd.Cmd):

    def __init__(self):
        super().__init__()
        self.image = LayeredImage()

    def do_reset(self, args):
        self.image = LayeredImage()

    def do_save(self, args):
        width, height, filename = args.split(" ")

        width = int(width)
        height = int(height)

        self.image(width, height, filename=filename)
#+END_SRC

As you can see each command receives its arguments as a single string and
it is up to the method to handle them - including conversions to appropriate
data types as is the case with the ~width~ and ~height~ arguments. For the sake
of being brief proper error handling has been omitted.

Now if we were to fire up the application we would be able to produce an image!

#+BEGIN_SRC
(Cmd) reset
(Cmd) save 1920 1080 image.png
#+END_SRC

Of course this image is currently empty so next we should add the ability for
the user to place shapes on the image. We'll create two more commands ~circle~
and ~square~.

#+BEGIN_SRC python
from stylo.color import FillColor
from stylo.shape import Circle, Square

class StyloPrompt(cmd.Cmd):
    ...

    def do_circle(self, args):
        x, y, r, color = args.split(" ")

        circle = Circle(float(x), float(y), float(r), fill=True)
        self.image.add_layer(circle, FillColor(color))

    def do_square(self, args):
        x, y, size, color = args.split(" ")

        square = Square(float(x), float(y), float(size))
        self.image.add_layer(square, FillColor(color))
#+END_SRC

Now when we use the application we can create something a bit more
interesting than a snowman in a blizzard! :smile:

#+CAPTION: Number 3 on a dice
[[/images/dice.png][file:/images/dice.png]]

#+BEGIN_SRC
(Cmd) square 0 0 1.75 000000
(Cmd) circle 0 0 0.3 ffffff
(Cmd) circle -0.5 0.5 0.3 ffffff
(Cmd) circle 0.5 -0.5 0.3 ffffff
(Cmd) save 1920 1080 image.png
#+END_SRC

** Getting Help

Now that we have a few commands available we need to tell users how they can be
used. If we were to use the ~help~ command we would see something like the
following.

#+BEGIN_SRC
(Cmd) help

Documented commands (type help <topic>):
========================================
help

Undocumented commands:
======================
circle reset save square
#+END_SRC

Not very helpful.

Thankfully the default help system doesn't require much to get started, all we
have to do is add docstrings to our ~do_*~ methods!

#+BEGIN_SRC python
def do_circle(self, args):
    """usage: circle <x> <y> <r> <color>

    This command will draw a circle centered at the coordinates (<x>, <y>)
    with radius given by <r>. The <color> argument is a 6 digit hex
    representing a color in RGB format.
    """
    ...
#+END_SRC

Now if we were to run ~help circle~

#+BEGIN_SRC
(Cmd) help circle
circle <x> <y> <r> <color>

        This command will draw a circle centered at the coordinates (<x>, <y>)
        with radius given by <r>. The <color> argument is a 6 digit hex
        representing a color in RGB format.
#+END_SRC

Much better :smile:

** Giving Feedback

Right now our program is... ok. The user can type in a few commands and they
can create some images, but it's not much of a step up from using the library
as they still have to wait until they have saved their image before
they can view it. Add in the fact that our program isn't that flexible they may
as well be using the library directly.

If only there was some way we could show the user their image as they build it
up a command at a time...

Enter ~postcmd~! This handy method is called each time our program has
processed a command - we can use this to redraw the image each time.
Then "all" we have to do if find a way to display the current image to the user.

After some searching and head scratching I was able to come up with the
following ~matplotlib~ incantation to add our image to a figure and display it.

#+BEGIN_SRC python
...
import matplotlib.pyplot as plt

class StyloPrompt(cmd.Cmd):

    def __init__(self):
        ...

        self.fig, self.ax = plt.subplots(1)
        self.ax.get_xaxis().set_visible(False)
        self.ax.get_yaxis().set_visible(False)

        self.update_image()
    ...

    def postcmd(self, stop, line):

        if stop:
            return True

        self.update_image()

    def update_image(self):

        # Re-render the image
        self.image(1920, 1080)

        # Update the preview
        self.ax.imshow(image.data)
        self.fig.show()
#+END_SRC

I won't go into too much detail here but I will point out a few things.

- The ~stop~ argument to ~postcmd~ indicates whether the previous command
  wanted to exit the program (by returning ~True~). We have the option of
  overriding that by not returning ~True~. But in our case we will just pass
  the message on.

- Matplotlib is smart enough to use an existing window when calling ~show()~ on
  a figure so all we have to do is update the plot in the axis object

- In the ~__init__~ method we are disabling the scale on the axis so that the
  user doesn't see something that looks like a graph.

** Finishing Touches

With most of the functionality out of the way we can look at tweaking
some things to make the overall experience nicer.

*** Exiting the Program

So far we don't have a clean way to close the program, we can hit ~Ctrl-C~ to
terminate the script but it results in Python printing a traceback and it looks
like an error in our program more than anything.

Instead we can override the ~default~ method on our class. This method is
called whenever the program doesn't recogise the user's input as a valid
command and we can use it to look at all of the user's input (not just the
~args~) and decide what to do with it.

In this case we will say that the program will exit whenever the user types a
~q~ or we receive an ~EOF~ character (~Ctrl-D~).

#+BEGIN_SRC python
class StyloPrompt(cmd.Cmd):
    ...

    def default(self, line):
        if line == "q" or line == "EOF":
            return True

        return super().default(line)
#+END_SRC

*** Changing the Prompt

We can change the default prompt ~(Cmd)~ by setting the ~prompt~ attribute on
our class.

#+BEGIN_SRC python
class StyloPromt(Cmd):
    prompt = "-> "
    ...
#+END_SRC

*** Greeting the User

Currently when our program starts it simply shows them the prompt, which if
they are using it for the first time they probably won't know where to start.
To help them get started we can set the ~intro~ attribute to contain a welcome
message.

#+BEGIN_SRC python
...
from stylo import __version__

intro_text = """\
Interactive Shell for Stylo v{}
----------------------------------

Type `q` or `Ctrl-D` to quit.
Type `help` or `?` for an overview `help <command>` for more details.
"""

class StyloPrompt(cmd.Cmd):
    intro = intro_text.format(__version__)
    ...

#+END_SRC

Now when the user starts the program they should have enough information to
continue from there.

#+BEGIN_SRC
Interactive Shell for Stylo v0.9.1
----------------------------------

Type `q` or `Ctrl-D` to quit.
Type `help` or `?` for an overview `help <command>` for more details.

->
#+END_SRC

There are also ~doc_header~, ~misc_header~ and ~undoc_header~ that you can set
to include even more information at different points in your program. You can
refer to the [[https://docs.python.org/3/library/cmd.html][documentation]] for more details.

** Wrapping Up

I can't believe I only just found out about this module. I hope you found this
as useful as I did and I strongly encourage you to take a look at the
[[https://docs.python.org/3/library/cmd.html][documentation]] as there are features there that I didn't get around to
mentioning - such as completion!

For those interested the final version of this program (with a few minor
tweaks) is available as a [[https://gist.github.com/alcarney/2f58820dd7a7c999197a450cf2069954][Gist]] on Github. I think what I like most
about this module is that it requires very little code before you start seeing
real results - Our entire application is only 155 lines of code!

* DONE Introducing Stylo Doodles!                              :stylo:python:
:PROPERTIES:
:EXPORT_DATE: 2018-10-12
:EXPORT_FILE_NAME: introducing-stylo-doodles
:EXPORT_DESCRIPTION: Introducing the new community gallery for stylo
:END:

A few weeks back at [[https://2018.pyconuk.org/][PyConUK]] I gave my first [[https://youtu.be/F5jSUJVymXk?t=3480][lighting talk]]
at a conference. During that talk I spoke publically about [[https://github.com/alcarney/stylo][stylo]] for
the first time. Stylo is a Python library that I have been working on for just
over a year and a half and it aims to make the creation of images easier by
bringing together ideas from programming and mathematics.

Version [[https://alcarney.github.io/stylo/changes.html][0.6.0]] was recently released which included the first feature
that wasn't written by me! It's very exciting not only to see other people
starting to take an interest in the project but taking the time to make a
contribution!

Now that stylo seems to be getting to the point that it might me useful to
other people wouldn't it be great if there was a community driven example
gallery that people could get inspired by? - Well now there is! And it's
called [[https://alcarney.github.io/stylo-doodles][Stylo Doodles]]

[[/images/stylo-doodles.png][file:/images/stylo-doodles.png]]

#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT

All the examples are written as a [[https://jupyter.org][Jupyter Notebook]] and can be submitted to the
gallery by opening a pull request against the stylo-doodles [[https://github.com/alcarney/stylo-doodles][repository]]. A small
python application is then run that builds the website and pushes the update to
the live website.

** Current Features

The gallery website is very new but it currently has the following features

- All images are displayed in a grid on the homepage with the order randomly
  chosen each time the website is built.
- Each image has its own page (as shown above) which displays the full
  resolution image along with information about the author, image and the
  version of stylo used to generate it.
- The source code from the notebook is extracted and is also displayed
  alongside the image.
- You can also play around with any example *live in your browser* if you
  follow the [[https://mybinder.org/v2/gh/alcarney/stylo-doodles/master][binder]] link in the repository's README.

** Adding Your Own Example

If you have an image that you would like to share there are only a couple of
things you need to do:

1. Your image *must* be stored in a variable called ~image~. The build process
   will [[https://jupyter-notebook.readthedocs.io/en/stable/examples/Notebook/Importing%2520Notebooks.html][import your notebook]] as a Python module and look for a variable called
   ~image~.

2. You also need to provide some additional information to the build system
   about your example in the form of a Python dictionary. This dictionary
   *must* be called ~info~ and it must be in *very first cell of the notebook*

   #+BEGIN_SRC python
   info = {
        "title": "Jack-O-Lantern",
        "author": "Alex Carney",
        "github_username": "alcarney",
        "stylo_version": "0.6.0",
        "dimensions": (1920, 1080)
    }
   #+END_SRC

   The ~stylo_version~ field should be set to the value of ~stylo.__version__~
   at the time you created your image. The ~dimensions~ is tuple of the form
   ~(width, height)~ and will be used by the build system to determine the size
   of the image (in pixels) when it renders the full size copy for its detail
   page.

3. Once your example is ready open a pull request adding your notebook to the
   ~notebooks/~ folder to the repository.

Be sure to check out the existing [[https://github.com/alcarney/stylo-doodles/tree/master/notebooks][examples]] to use as a guide or drop by the
stylo [[https://gitter.im/stylo-py/Lobby][Gitter]] room if you get stuck we'll be more than happy to help!

** Future Developments

Stylo Doodles is far from finished aside from adding examples there are many
more things that could be added to the website:

- *User profiles:* A page for every author, which lists the examples they
  have contributed to the gallery.

- *Search*: As the number of images grow users would probably want to be able
  to tag their images and be able to narrow down the list of images on the
  homepage.

- *Recently Added:* Since the order of the homepage is random, as the number
  of images increases the chance of a new image being buried at the bottom will
  also increase, it would be good to have a way of sorting the images by date
  added.

- *Descriptions:* Jupyter Notebooks support more than just code. Cells
  containing markdown can be placed in between code cells to provide extra
  context and explanation. It would be great if we could include these on the
  site as well.

If you are looking for a web based python project to get involved with this
would be a great one to get started with and I would be more than happy to have
a few contribuitors to work on this (or even stylo itself!) with me.

* DONE I've Started a Blog... Again!                               :blogging:
:PROPERTIES:
:EXPORT_DATE: 2018-09-22
:EXPORT_FILE_NAME: first-article
:EXPORT_DESCRIPTION: First article with ox-hugo
:END:

Not that you would have known it, but I've had a blog since 2014.  Well 2015 if
you're feeling generous, the first (and only) post went up in the last few
hours of New Year's Eve. It was a look back on some of the projects I had
worked on that year and I announced my intentions to start blogging.

Fast forward nearly 4 years and here I am announcing my intentions to start
blogging - *again*. So I guess you are wondering what happened?

I got lost.

My first attempt at running a blog was using [[https://jekyllrb.com][Jekyll]] and for some mystical reason
(It's been so long I can't actually remember why), I decided that it was not the
static site generator I was looking for. So I promptly set off on a voyage of
discovery in search of the ultimate static site generator.

#+BEGIN_EXPORT html
<!--more-->
#+END_EXPORT

Here is a list of some of the other static site generators I have played with
over the years in no particular order:

- [[http://www.metalsmith.io/][Metalsmith]]: Written in Javascript, this one appealed to me with
  its "everything is a plugin" approach. In theory I should be able to add any
  feature I wanted simply by finding/writing the right plugin.

- [[https://jaspervdj.be/hakyll/][Hakyll]]: I was going through a Haskell phase and I thought it would
  be a great idea to have my blog powered with it as well. *Haskell all the
  things!*

- [[http://www.sphinx-doc.org][Sphinx]]: Sphinx is an awesome tool for writing
  documentation. A big part of that is [[http://docutils.sourceforge.net/rst.html][reStructuredText]], add in the [[https://ablog.readthedocs.io/][ABlog]]
  extension and you should have a great setup for a blog.

- [[https://blog.getpelican.com/][Pelican]] & [[https://getnikola.com/][Nikola]]: However as Sphinx is primarily built
  for documentation projects, I found that I was fighting it more
  than anything. That led me to take a look at Pelican and Nikola, both written
  in Python and have support for reStructuredText and
  [[http://jupyter.org/][Jupyter]].

- [[https://vuepress.vuejs.org/][Vuepress]]: Having played around a bit with [[https://vuejs.org/][VueJS]], the
  thought of being able to take a dynamic site written in a powerful frontend
  framework and make a static site out of it seemed appealing. The best of both
  worlds.

- [[https://gohugo.io/][Hugo]]: Who *doesn't* want a static site generator written in Go? :)

- [[https://www.gnu.org/software/emacs/][Emacs]] & [[https://orgmode.org/][org-mode]]: Yes, [[https://orgmode.org/worg/org-blog-wiki.html][you can]] use emacs
  as a static site generator.

At this point you might be wondering what was wrong with all of the above so
that after nearly 4 years of tinkering I still had nothing to show for it?

Nothing. Absolutely nothing.

The problem was with me. I wanted complete control over the output, from the
contents of ~<head>~ to the CSS styling of links. There would always
be a point where I would start fighting against the very abstractions
designed to make my life easier! It got to the point where I even tried writing
my own static site generator...

** A New Perspective

After endless hours lost fiddling with scripts and stylesheets I stumbled
across a quote on the internet that would snap me out of my spiral of perpetual
procrastination.

#+BEGIN_QUOTE
    The technology you use *impresses no one*.

    The experience you create with it is *everything*. -- [[https://twitter.com/ideakitchn?lang=en][Sean Gerety]]
#+END_QUOTE

I have found myself saying this again and again, so much so that I think it may
have fundamentally altered the way I think about programming. I fell into a
trap of getting caught up in the merits of the technology for the sake of the
technology itself and lost sight of the experience - the blog itself.

Rejuvenated I've gone back to where it all started and have started using [[https://jekyllrb.com][Jekyll]]
again. I'm using the [[https://fongandrew.github.io/hydeout/][Hydeout]] theme as it's built in a way that allows me to make
a few (minor!) tweaks of my own. Within a few hours I was already working on the
draft that became this blog post, a place I never even got to in most of my
previous attempts.

It turns out that Markdown is a perfectly acceptable format for a blog. You
don't have to engineer your blog's theme from the ground up especially when a
prebuilt theme exists in the style you were going to build yourself anyway. It
doesn't matter that your blog can seamlessly format a Jupyter Notebook as a
regular blog post when you don't have any notebooks to publish in the first
place...

What matters is the content itself, that you have something interesting to say
and you have some way of making that available to other people. Everything else
is just an implementation detail, which if done right is invisible to the
consumers of your content anyway.

It's strange that I had learn something that is probably obvious to most people
the hard way but I'm here now. If you are reading this then things are looking
up but I can't quite declare victory as I'm no further forward than I was 4
years ago, first let's see if I make it to blog post number #2...
