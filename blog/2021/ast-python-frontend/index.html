
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Creating a CPython Extension &#8212; Blog  documentation</title>

    
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    
    
    
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    
    
    <link rel="stylesheet" type="text/css" href="../../../_static/css/styles.css" />
    

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex/" />
    <link rel="search" title="Search" href="../../../search/" /> 
  </head><body class="flex flex-col justify-between min-h-screen overflow-x-hidden bg-gray-100 ">
    <div class="flex flex-grow">
        <input id="menu-state" type="checkbox" class="hidden" />
        <aside class="flex justify-between flex-shrink-0 transition-all duration-500 bg-white border-r -ml-80 lg:ml-0">
            <div class="flex flex-col justify-between h-full border-r w-80">
                <div class="sticky top-0 flex flex-col h-screen"> 
                    
                    <div id="profile-card" class="full-profile">
    <img class="" src="https://github.com/alcarney.png"/>
    <h2 class=""><a href="/">Alex Carney</a></h2>
</div>
                    
                    <div id="searchbox" style="display: none" role="search" class="px-4 py-4">
    <form class="flex justify-between px-2 py-1 bg-gray-100 border-2 rounded search focus-within:border-green-600" action="../../../search/" method="get">
        <label class="mr-2 text-gray-500" for="sbox">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search">
                <circle cx="11" cy="11" r="6" />
                <path d="m21 21-4.35-4.35" />
            </svg>
        </label>
        <input id="sbox" class="flex-grow bg-gray-100 focus:outline-none" type="search" name="q" placeholder="Search..." aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
    </form>
</div>
<script>$('#searchbox').show(0);</script>
                    
                    
    
<nav class="flex flex-col text-center">
    <a class="text-green-600 py-1 border-t text-lg hover:bg-gray-50" href="/blog">Blog</a>
    <a class="text-green-600 py-1 border-t text-lg hover:bg-gray-50" href="/code">Code</a>
    <a class="text-green-600 py-1 border-t text-lg hover:bg-gray-50" href="/notes">Notes</a>
</nav>
                    
                    <div class="flex-shrink overflow-auto">

<div class="grid justify-between p-4 text-gray-500 border-t" style="grid-template-columns: 24px auto">
    
    <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
</svg>
    <span class="ml-2 text-right">Jan 13, 2021</span>
    

    <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />
</svg>
    <ul class="text-right">
        
        <li class="mb-1">
            <a href="../../tag/c/" class="px-2 my-1 text-green-600 border border-green-600 rounded bg-green-50">
                #c
            </a>
        </li>
        
        <li class="mb-1">
            <a href="../../tag/python/" class="px-2 my-1 text-green-600 border border-green-600 rounded bg-green-50">
                #python
            </a>
        </li>
        
        <li class="mb-1">
            <a href="../../tag/prog-langs/" class="px-2 my-1 text-green-600 border border-green-600 rounded bg-green-50">
                #prog-langs
            </a>
        </li>
        
    </ul>
</div>
<nav id="localtoc" class="p-4 border-t">
    <ul>
<li><a class="reference internal" href="#">Creating a CPython Extension</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#constructing-an-ast-representation">Constructing an AST Representation</a></li>
<li><a class="reference internal" href="#setting-up-the-c-extension">Setting up the C Extension</a><ul>
<li><a class="reference internal" href="#building-the-extension">Building the Extension</a></li>
</ul>
</li>
<li><a class="reference internal" href="#converting-between-python-and-c">Converting Between Python and C</a><ul>
<li><a class="reference internal" href="#parsing-function-arguments">Parsing Function Arguments</a></li>
<li><a class="reference internal" href="#constructing-the-c-ast">Constructing the C AST</a><ul>
<li><a class="reference internal" href="#allocating-memory">Allocating Memory</a></li>
<li><a class="reference internal" href="#inspecting-nodes">Inspecting Nodes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#converting-the-node">Converting the Node</a></li>
<li><a class="reference internal" href="#traversing-the-tree">Traversing the Tree</a></li>
<li><a class="reference internal" href="#returning-the-result">Returning the Result</a></li>
</ul>
</li>
<li><a class="reference internal" href="#final-thoughts">Final Thoughts</a><ul>
<li><a class="reference internal" href="#best-practice">Best Practice?</a></li>
<li><a class="reference internal" href="#another-approach">Another approach</a></li>
</ul>
</li>
</ul>
</li>
</ul>

</nav>
                    </div>
                    
                    <footer class="w-full p-4 mt-auto text-white bg-gray-700">
                        <div class="flex justify-between">
    <div></div>

    <div class="flex justify-between space-x-4">
        <a target="_blank" rel="noreferrer noopener" href="https://github.com/alcarney">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="w-8 h-8">
                <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg>
        </a>

        <a target="_blank" rel="noreferrer noopener" href="https://twitter.com/alcarneyme">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="w-8 h-8">
                <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
            </svg>
        </a>

        <a target="_blank" rel="noreferrer noopener" href="https://instagram.com/alcarneyme">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="w-8 h-8">
                <rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect>
                <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path>
                <line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>
            </svg>
        </a>

        <a target="_blank" rel="noreferrer noopener" href="https://www.youtube.com/channel/UC5GPflgRWhnCxA0BllfP5CA">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="w-8 h-8">
                <path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"></path>
                <polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"></polygon>
            </svg>
        </a>
    </div>

    <div></div>
</div>
                    </footer>
                </div>
            </div>     
        </aside>
        
        <main class="w-full mx-auto lg:pr-0">
            <div class="sticky top-0 z-50 mt-0 transition-all duration-300 bg-white border-b shadow-md lg:shadow-none lg:relative lg:-mt-16">
                <label class="flex h-16 text-gray-600 transition" for="menu-state">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="w-8 h-8 my-auto" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><path d="M5 12h14M12 5l7 7-7 7"/></svg>
                </label>
            </div> 

            <div id="content" class="mx-2 my-8">
                <div class="max-w-3xl mx-auto">
                    

<article class="p-4 prose-sm prose bg-white border prose-md prose-green max-w-none">
    <div class="section" id="creating-a-cpython-extension">
<h1>Creating a CPython Extension<a class="headerlink" href="#creating-a-cpython-extension" title="Permalink to this headline">¶</a></h1>
<p><a class="reference internal" href="../../2020/ast-simple-eval/"><span class="doc">Previously</span></a>, as part of my exploration
into how programming languages are implemented, I wrote a very simple AST
evaluator that knew how to add and multiply floats together. Since constructing
these ASTs by hand is quite painful I thought it would be fun to come up with a
frontend to my “programming language” which could do it for me.</p>
<p>Now your typical frontend would be some kind of parser built into the
compiler/interpreter. However, while I’m definitely interested in parsing I
don’t quite feel like tackling that just yet. Instead I’m going to have Python
be the frontend and embed my toy language into it via a <a class="reference external" href="https://docs.python.org/3/extending/extending.html">CPython Extension</a></p>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Before diving into the detail I think it would be worth keeping in mind what we
want the end result to be. By the end of this post, we want to have a CPython
extension that allows us to write normal-ish Python code to construct a
representation of some expression</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ccalc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expression</span> <span class="o">=</span> <span class="p">(</span><span class="n">ccalc</span><span class="o">.</span><span class="n">Literal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expression</span>
<span class="go">Multiply&lt;Plus&lt;Literal&lt;1.0&gt;, Literal&lt;2.0&gt;&gt;, Literal&lt;3.0&gt;&gt;</span>
</pre></div>
</div>
<p>and then be able to pass this expression to the AST evaluator we wrote in the
previous post and have it compute the result</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ccalc</span><span class="o">.</span><span class="n">eval_ast</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
<span class="go">9.0</span>
</pre></div>
</div>
<p>If you’d rather skip all the exposition you can find the final codebase</p>
<p>We can break the implementation down into 3 main steps</p>
<ul>
<li><p><a class="reference internal" href="#ast-python-frontend-ast-repr"><span class="std std-ref">Constructing an AST Representation</span></a></p>
<p>We need an equivalent Python representation to the <code class="docutils literal notranslate"><span class="pre">AstNode</span></code> structure,
allowing the user to express the expression they want computed.</p>
</li>
<li><p><a class="reference internal" href="#ast-python-frontend-ext-setup"><span class="std std-ref">Setting up the C Extension</span></a></p>
<p>Before we can get to the fun part, there’s some setup required to get a
CPython extension up and running.</p>
</li>
<li><p><a class="reference internal" href="#ast-python-frontend-conversions"><span class="std std-ref">Converting Between Python and C</span></a></p>
<p>Finally we need to write the code that converts the Python representation into
the C representation, passing it off to the evaluator before converting the
result back into Python.</p>
</li>
</ul>
</div>
<div class="section" id="constructing-an-ast-representation">
<span id="ast-python-frontend-ast-repr"></span><h2>Constructing an AST Representation<a class="headerlink" href="#constructing-an-ast-representation" title="Permalink to this headline">¶</a></h2>
<p>To represent the AST in Python code we can create a class that captures the same
information as our <a class="reference internal" href="../../2020/ast-simple-eval/#ast-simple-eval-ast-repr"><span class="std std-ref">AstNode</span></a> struct from the C code</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AstNode</span><span class="p">:</span>

   <span class="n">LITERAL</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="n">PLUS</span> <span class="o">=</span> <span class="mi">1</span>
   <span class="n">MULTIPLY</span> <span class="o">=</span> <span class="mi">2</span>

   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
</pre></div>
</div>
<p>From there it’s simple enough to create some subclasses that help us fill out
the correct fields.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Literal</span><span class="p">(</span><span class="n">AstNode</span><span class="p">):</span>
   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
      <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">AstNode</span><span class="o">.</span><span class="n">LITERAL</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Plus</span><span class="p">(</span><span class="n">AstNode</span><span class="p">):</span>
   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
      <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">AstNode</span><span class="o">.</span><span class="n">PLUS</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Multiply</span><span class="p">(</span><span class="n">AstNode</span><span class="p">):</span>
   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
      <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">AstNode</span><span class="o">.</span><span class="n">MULTIPLY</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">)</span>
</pre></div>
</div>
<p>Technically that’s all we need but we haven’t really gained anything in terms of
usability, constructing an AST from the classes we have defined so far would be
just as painful as it was in C.</p>
<p>Thankfully though, we don’t have to stop here, by taking advantage of being able
to define implementations for arithmetic operations on our custom types we can
introduce a much nicer method of constructing expressions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AstNode</span><span class="p">:</span>
   <span class="o">...</span>

   <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

      <span class="c1"># Automatically convert python numbers to Literal(x) AST nodes</span>
      <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">AstNode</span><span class="p">):</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">AstNode</span><span class="p">):</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

      <span class="o">...</span>

   <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">Plus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

   <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">Plus</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

   <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">Multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

   <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">Multiply</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>Now if we wanted to construct an expression we can do so with fairly
straightforward Python code.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ccalc</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ccalc</span><span class="o">.</span><span class="n">Literal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>
<span class="go">Multiply&lt;Plus&lt;Literal&lt;1.0&gt;, Literal&lt;2.0&gt;&gt;, Literal&lt;3.0&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ccalc</span><span class="o">.</span><span class="n">Literal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">Plus&lt;Literal&lt;1.0&gt;, Literal&lt;6.0&gt;&gt;</span>
</pre></div>
</div>
<p>However, as shown with the second example above we need to be careful when
choosing the number to wrap in our <code class="docutils literal notranslate"><span class="pre">ccalc.Literal</span></code> class if we want to “catch”
the expression and construct our AST rather than have Python compute the value
directly</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">ccalc</span><span class="o">.</span><span class="n">Literal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">Plus&lt;Literal&lt;1.0&gt;, Multiply&lt;Literal&lt;2.0&gt;, Literal&lt;3.0&gt;&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="setting-up-the-c-extension">
<span id="ast-python-frontend-ext-setup"></span><h2>Setting up the C Extension<a class="headerlink" href="#setting-up-the-c-extension" title="Permalink to this headline">¶</a></h2>
<p>Using <a class="reference external" href="https://realpython.com/build-python-c-extension-module/">this tutorial</a> from Real Python as a guide I was able
to get a C Extension up and running surprisingly easily. Be sure to check out
the article for details but in short I ended up creating the following directory
structure</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.
├── ccalc
│   └── __init__.py
├── ccalcmodule.c
└── setup.py
</pre></div>
</div>
<p>Where the <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file contains the Python code we wrote in the previous
section and <code class="docutils literal notranslate"><span class="pre">ccalcmodule.c</span></code> contains the boilerplate needed to define a Python
module</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define PY_SSIZE_T_CLEAN</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Python.h&gt;</span><span class="cp"></span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span> <span class="nc">PyModuleDef</span><span class="w"> </span><span class="n">ccalcmodule</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">PyModuleDef_HEAD_INIT</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="s">&quot;_ccalc&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="s">&quot;Simple calculator implemented in C&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="mi">-1</span><span class="p">,</span><span class="w"></span>
<span class="w">   </span><span class="n">ccalc_methods</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">PyMODINIT_FUNC</span><span class="w"></span>
<span class="nf">PyInit__ccalc</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">PyModule_Create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ccalcmodule</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code> struct as the name implies, defines some basic information
about the module</p>
<ul class="simple">
<li><p>It’s name <code class="docutils literal notranslate"><span class="pre">_ccalc</span></code>, specifies what our module is called when we <code class="docutils literal notranslate"><span class="pre">import</span></code>
it in regular Python code</p></li>
<li><p>The next argument is the module’s docstring</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code> is something to do with sub-interpreters?</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ccalc_methods</span></code> is an array of structs delcaring all the functions this module
exposes to the interpreter.️</p></li>
</ul>
<p>Something that caught me out is that the <code class="docutils literal notranslate"><span class="pre">PyInit_&lt;module</span> <span class="pre">name&gt;</span></code> function <em>must</em>
match the name we gave the module in <code class="docutils literal notranslate"><span class="pre">PyModuleDef</span></code>,  since the module name is
<code class="docutils literal notranslate"><span class="pre">_ccalc</span></code> I needed an additional <code class="docutils literal notranslate"><span class="pre">_</span></code> character in the name so that the module can
be registered correctly.</p>
<p>The methods declared in the <code class="docutils literal notranslate"><span class="pre">ccalc_methods</span></code> array follow a similar pattern</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyMethodDef</span><span class="w"> </span><span class="n">ccalc_methods</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="s">&quot;hello_world&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">method_hello_world</span><span class="p">,</span><span class="w"> </span><span class="n">METH_VARARGS</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Print &#39;Hello, World!&#39;.&quot;</span><span class="p">},</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">}</span><span class="w"> </span><span class="c1">// I think this is required so that Python knows when</span>
<span class="w">                         </span><span class="c1">// it&#39;s reached the end of the array</span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hello_world</span></code> is the name we want regular Python code to use when calling this
method</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">method_hello_world</span></code> is the name of the function in our C code</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">METH_VARARGS</span></code> tells Python the kinds of arguments our function should be
called with. Check out the <a class="reference external" href="https://docs.python.org/3/extending/extending.html#the-module-s-method-table-and-initialization-function">documentation</a> for more details.</p></li>
<li><p>The final parameter sets the docstring for the function</p></li>
</ul>
<p>Finally we need the the actual method definition itself.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="o">*</span><span class="w"></span>
<span class="nf">method_hello_world</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">Py_RETURN_NONE</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="section" id="building-the-extension">
<h3>Building the Extension<a class="headerlink" href="#building-the-extension" title="Permalink to this headline">¶</a></h3>
<p>To my surprise, this was the easiest step of them all. Rather than worrying
about writing a <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> or providing the right flags to link against my
version of Python, it turns out that <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> takes care of all those
details.</p>
<p>All I had to do was write a standard <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> file, just with some additional
information about the extension itself</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>

<span class="n">ccalcmod</span> <span class="o">=</span> <span class="n">Extension</span><span class="p">(</span><span class="s2">&quot;_ccalc&quot;</span><span class="p">,</span> <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ccalcmodule.c&quot;</span><span class="p">],</span> <span class="n">language</span><span class="o">=</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ccalc&quot;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s2">&quot;1.0.0&quot;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;A simple calculator implemented in C&quot;</span><span class="p">,</span>
    <span class="n">packages</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ccalc&quot;</span><span class="p">],</span>
    <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span><span class="n">ccalcmod</span><span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<p>With the packaging defined a <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></code> was all that was needed
to build and install the extension into my virtual environment.</p>
<div class="dropdown highlight-none notranslate"><div class="highlight"><pre><span></span>(.env) $ python setup.py install

running install
running bdist_egg
running egg_info
creating ccalc.egg-info
writing ccalc.egg-info/PKG-INFO
writing dependency_links to ccalc.egg-info/dependency_links.txt
writing top-level names to ccalc.egg-info/top_level.txt
writing manifest file &#39;ccalc.egg-info/SOURCES.txt&#39;
reading manifest file &#39;ccalc.egg-info/SOURCES.txt&#39;
writing manifest file &#39;ccalc.egg-info/SOURCES.txt&#39;
installing library code to build/bdist.linux-x86_64/egg
running install_lib
running build_py
creating build
creating build/lib.linux-x86_64-3.8
creating build/lib.linux-x86_64-3.8/ccalc
copying ccalc/__init__.py -&gt; build/lib.linux-x86_64-3.8/ccalc
running build_ext
building &#39;_ccalc&#39; extension
creating build/temp.linux-x86_64-3.8
x86_64-linux-gnu-gcc -pthread -Wno-unused-result -Wsign-compare -DNDEBUG -g -fwrapv -O2 -Wall -g -fstack-protector-strong -Wformat -Werror=format-security -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -fPIC -I/home/alex/Projects/scratch/.env/include -I/usr/include/python3.8 -c ccalcmodule.c -o build/temp.linux-x86_64-3.8/ccalcmodule.o
x86_64-linux-gnu-gcc -pthread -shared -Wl,-O1 -Wl,-Bsymbolic-functions -Wl,-Bsymbolic-functions -Wl,-z,relro -g -fwrapv -O2 -Wl,-Bsymbolic-functions -Wl,-z,relro -g -fwrapv -O2 -g -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 build/temp.linux-x86_64-3.8/ccalcmodule.o -o build/lib.linux-x86_64-3.8/_ccalc.cpython-38-x86_64-linux-gnu.so
creating build/bdist.linux-x86_64
creating build/bdist.linux-x86_64/egg
creating build/bdist.linux-x86_64/egg/ccalc
copying build/lib.linux-x86_64-3.8/ccalc/__init__.py -&gt; build/bdist.linux-x86_64/egg/ccalc
copying build/lib.linux-x86_64-3.8/_ccalc.cpython-38-x86_64-linux-gnu.so -&gt; build/bdist.linux-x86_64/egg
byte-compiling build/bdist.linux-x86_64/egg/ccalc/__init__.py to __init__.cpython-38.pyc
creating stub loader for _ccalc.cpython-38-x86_64-linux-gnu.so
byte-compiling build/bdist.linux-x86_64/egg/_ccalc.py to _ccalc.cpython-38.pyc
creating build/bdist.linux-x86_64/egg/EGG-INFO
copying ccalc.egg-info/PKG-INFO -&gt; build/bdist.linux-x86_64/egg/EGG-INFO
copying ccalc.egg-info/SOURCES.txt -&gt; build/bdist.linux-x86_64/egg/EGG-INFO
copying ccalc.egg-info/dependency_links.txt -&gt; build/bdist.linux-x86_64/egg/EGG-INFO
copying ccalc.egg-info/top_level.txt -&gt; build/bdist.linux-x86_64/egg/EGG-INFO
writing build/bdist.linux-x86_64/egg/EGG-INFO/native_libs.txt
zip_safe flag not set; analyzing archive contents...
__pycache__._ccalc.cpython-38: module references __file__
creating dist
creating &#39;dist/ccalc-1.0.0-py3.8-linux-x86_64.egg&#39; and adding &#39;build/bdist.linux-x86_64/egg&#39; to it
removing &#39;build/bdist.linux-x86_64/egg&#39; (and everything under it)
Processing ccalc-1.0.0-py3.8-linux-x86_64.egg
removing &#39;/home/alex/Projects/scratch/.env/lib/python3.8/site-packages/ccalc-1.0.0-py3.8-linux-x86_64.egg&#39; (and everything under it)
creating /home/alex/Projects/scratch/.env/lib/python3.8/site-packages/ccalc-1.0.0-py3.8-linux-x86_64.egg
Extracting ccalc-1.0.0-py3.8-linux-x86_64.egg to /home/alex/Projects/scratch/.env/lib/python3.8/site-packages
ccalc 1.0.0 is already the active version in easy-install.pth

Installed /home/alex/Projects/scratch/.env/lib/python3.8/site-packages/ccalc-1.0.0-py3.8-linux-x86_64.egg
Processing dependencies for ccalc==1.0.0
Finished processing dependencies for ccalc==1.0.0
</pre></div>
</div>
<p>With the C code sorted and building, we can import it in Python code and call
functions from it just as we would with any other module.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">_ccalc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_ccalc</span><span class="o">.</span><span class="n">hello_world</span><span class="p">()</span>
<span class="go">Hello, World!</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="converting-between-python-and-c">
<span id="ast-python-frontend-conversions"></span><h2>Converting Between Python and C<a class="headerlink" href="#converting-between-python-and-c" title="Permalink to this headline">¶</a></h2>
<p>Now for the fun part! It’s time to write a method for our extension module
<code class="docutils literal notranslate"><span class="pre">method_eval_ast</span></code> that takes a Python representation of the AST and converts it
into our C representation before executing it and passing the result back up to
Python.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="o">*</span><span class="w"></span>
<span class="nf">method_eval_ast</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Be sure to expose the new method to the module</span>
<span class="k">static</span><span class="w"> </span><span class="n">PyMethodDef</span><span class="w"> </span><span class="n">ccalc_methods</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="p">{</span><span class="s">&quot;eval_ast&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">method_eval_ast</span><span class="p">,</span><span class="w"> </span><span class="n">METH_VARARGS</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Evaluate the given ast.&quot;</span><span class="p">},</span><span class="w"></span>
<span class="w">   </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This can be broken down into a three step process</p>
<ul class="simple">
<li><p><a class="reference internal" href="#ast-python-frontend-function-args"><span class="std std-ref">Parsing Function Arguments</span></a></p></li>
<li><p><a class="reference internal" href="#ast-python-frontend-c-ast"><span class="std std-ref">Constructing the C AST</span></a></p></li>
<li><p><a class="reference internal" href="#ast-python-frontend-return"><span class="std std-ref">Returning the Result</span></a></p></li>
</ul>
<div class="section" id="parsing-function-arguments">
<span id="ast-python-frontend-function-args"></span><h3>Parsing Function Arguments<a class="headerlink" href="#parsing-function-arguments" title="Permalink to this headline">¶</a></h3>
<p>When writing a <code class="docutils literal notranslate"><span class="pre">METH_VARARGS</span></code> style function, it gets called with 2 parameters
<code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">args</span></code>. <code class="docutils literal notranslate"><span class="pre">self</span></code> in this case is a reference to our <code class="docutils literal notranslate"><span class="pre">_ccalc</span></code> module and
<code class="docutils literal notranslate"><span class="pre">args</span></code> is a reference to a tuple containing the arguments that were passed to
our function.</p>
<p>As the contents of this tuple can be arbitrary it’s up to our code to correctly
interpret the values that have been given to it. Thankfully Python provides a
handy function <code class="docutils literal notranslate"><span class="pre">PyArg_ParseTuple</span></code> that can take care of this for us.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">PyArg_ParseTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;O&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">obj</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>This function takes a <a class="reference external" href="https://docs.python.org/3/c-api/arg.html#parsing-arguments">format string</a> that specifies the
number and type of arguments we expect to be given. In this case <code class="docutils literal notranslate"><span class="pre">&quot;O&quot;</span></code> says that
we want to take a single object - our AST. We also need to pass the correct
number of pointers into this function so that it can “return” the parsed values
to us.</p>
<p>In the case of invalid arguments being given, this function will set the global
error indicator for us with the correct error message. So all that would be left
for us to do is to return <code class="docutils literal notranslate"><span class="pre">NULL</span></code> which indicates to the code calling us that
there was an error. See the documentation on <a class="reference external" href="https://docs.python.org/3/c-api/exceptions.html">error handling</a> for more details</p>
</div>
<div class="section" id="constructing-the-c-ast">
<span id="ast-python-frontend-c-ast"></span><h3>Constructing the C AST<a class="headerlink" href="#constructing-the-c-ast" title="Permalink to this headline">¶</a></h3>
<p>With a reference to the Python object that (hopefully!) represents a valid AST
it’s time to do the conversion into our C representation. To do this we’ll write
a function dedicated to handling the conversion and call it from
<code class="docutils literal notranslate"><span class="pre">method_eval_ast</span></code></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">AstNode</span><span class="w"> </span><span class="o">*</span><span class="n">ast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AstTree_FromPyObject</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ast</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>The first step is to dynamically allocate enough memory to store the C
representation. Easy enough to do, assuming that you know the size of the
tree…</p>
<div class="section" id="allocating-memory">
<h4>Allocating Memory<a class="headerlink" href="#allocating-memory" title="Permalink to this headline">¶</a></h4>
<p>It took me a while to realise it, but even though we’re writing C code we are
still within the Python interpreter. This means we still have access to all the standard
Python functions - we just need to look up their C equivalents. Why not just ask the
tree itself how big it is by calling <code class="docutils literal notranslate"><span class="pre">len()</span></code> on it?</p>
<p>After a quick trip to the documentation I discover that <code class="docutils literal notranslate"><span class="pre">len</span></code> is “spelt”
<code class="docutils literal notranslate"><span class="pre">PyObject_Length</span></code> in the C API, add some of the required book keeping and we
should be able to allocate enough space</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">AstNode</span><span class="o">*</span><span class="w"></span>
<span class="nf">AstTree_FromPyObject</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">num_nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyObject_Length</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">num_nodes</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="n">AstNode</span><span class="w"> </span><span class="o">*</span><span class="n">ast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">num_nodes</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">AstNode</span><span class="p">));</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ast</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Something important to note here, up until now we’ve been calling into the
Python C API which has been taking care of reporting any errors it encounters.
However, the call to <code class="docutils literal notranslate"><span class="pre">malloc</span></code> is now our code and it’s our responsibility to
correctly report any errors we counter.</p>
<p>If we were to leave the code as is and this call to <code class="docutils literal notranslate"><span class="pre">malloc</span></code> fails, Python would
know that an error had occured but not be able to tell the user what was wrong.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ccalc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">_ccalc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_ccalc</span><span class="o">.</span><span class="n">eval_ast</span><span class="p">(</span><span class="n">ccalc</span><span class="o">.</span><span class="n">Literal</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="gr">SystemError</span>: <span class="n">&lt;built-in function eval_ast&gt; returned NULL without setting an error</span>
</pre></div>
</div>
<p>Instead we also need to call <code class="docutils literal notranslate"><span class="pre">PyErr_SetString</span></code> to raise the appropriate
exception that describes our error.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">AstNode</span><span class="w"> </span><span class="o">*</span><span class="n">ast</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">num_nodes</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">AstNode</span><span class="p">));</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ast</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_MemoryError</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Unable to allocate memory for the AST.&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>With the information set, Python is able to report a much better error
message to the user</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ccalc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">_ccalc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_ccalc</span><span class="o">.</span><span class="n">eval_ast</span><span class="p">(</span><span class="n">ccalc</span><span class="o">.</span><span class="n">Literal</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">   File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="gr">MemoryError</span>: <span class="n">Unable to allocate memory</span>
</pre></div>
</div>
<p>Finally let’s not forget to jump back to the Python code and implement <code class="docutils literal notranslate"><span class="pre">__len__</span></code>
on our <code class="docutils literal notranslate"><span class="pre">AstNode</span></code> class.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AstNode</span><span class="p">:</span>
   <span class="o">...</span>

   <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
      <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
      <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span>
</pre></div>
</div>
</div>
<div class="section" id="inspecting-nodes">
<h4>Inspecting Nodes<a class="headerlink" href="#inspecting-nodes" title="Permalink to this headline">¶</a></h4>
<p>With the memory to hold the tree allocated it’s time to start on the actual
conversion. To handle this we’ll write another function <code class="docutils literal notranslate"><span class="pre">AstNode_FromPyObject</span></code>
that we can recursively call whenever we need to descend down a branch. This
function will take a reference <code class="docutils literal notranslate"><span class="pre">obj</span></code> to the Python representation of the node
we’re currently converting, another reference <cite>ast</cite> to the memory we allocated
and finally an <code class="docutils literal notranslate"><span class="pre">index</span></code> into the array that we should write the node to.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"></span>
<span class="nf">AstNode_FromPyObject</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">AstNode</span><span class="w"> </span><span class="o">*</span><span class="n">ast</span><span class="p">,</span><span class="w"> </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">AstNode</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">astindex</span><span class="p">];</span><span class="w"></span>
<span class="w">   </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The first step in the process is to determine the type of node we are
converting, which we can do by inspecting the value of the <code class="docutils literal notranslate"><span class="pre">type</span></code> field.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyObject_GetAttrString</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;type&quot;</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">long</span><span class="w"> </span><span class="n">node_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyLong_AsLong</span><span class="p">(</span><span class="n">type</span><span class="p">);</span><span class="w"></span>
<span class="n">Py_DECREF</span><span class="p">(</span><span class="n">type</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The call to <code class="docutils literal notranslate"><span class="pre">PyObject_GetAttrString</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">obj.type</span></code> in Python and
returns a <strong>new reference</strong> to a generic Python object. In order to get an
actual number we need to use <code class="docutils literal notranslate"><span class="pre">PyLong_AsLong</span></code> to convert it.</p>
<p>In theory <code class="docutils literal notranslate"><span class="pre">type</span></code> could be a reference to anything, so there’s always the chance
that <code class="docutils literal notranslate"><span class="pre">PyLong_AsLong</span></code> could fail in which case it would return <code class="docutils literal notranslate"><span class="pre">-1</span></code>. As stated in
<a class="reference external" href="https://docs.python.org/3/c-api/long.html?highlight=aslong#c.PyLong_AsLong">the documentation</a> we should really be performing extra checks here to determine
if the value is actually <code class="docutils literal notranslate"><span class="pre">-1</span></code> or if there was an error but I’ve decided to omit
those for now.</p>
<p>Something else to note is that <code class="docutils literal notranslate"><span class="pre">type</span></code> was a <strong>new reference</strong> and since Python
uses <a class="reference external" href="https://en.wikipedia.org/wiki/Reference_counting">Reference Counting</a> internally it’s our responsibility to decrement the
count (using <code class="docutils literal notranslate"><span class="pre">Py_DECREF</span></code>) when we are finished with it - at least that’s what I
think should be done based on what I found in the documentation on <a class="reference external" href="https://docs.python.org/3/extending/extending.html#ownership-rules">ownership</a></p>
</div>
</div>
<div class="section" id="converting-the-node">
<h3>Converting the Node<a class="headerlink" href="#converting-the-node" title="Permalink to this headline">¶</a></h3>
<p>Now that we have an integer <code class="docutils literal notranslate"><span class="pre">node_type</span></code> that corresponds with one of the
<code class="docutils literal notranslate"><span class="pre">AstNodeType</span></code> enum entries we can use a <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement and start writing the
conversion code for each type in turn.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">switch</span><span class="p">(</span><span class="n">node_type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">case</span><span class="w"> </span><span class="nl">AST_LITERAL</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">   </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyObject_GetAttrString</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;value&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="p">}</span><span class="w"></span>

<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyFloat_AsDouble</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">Py_DECREF</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w"></span>

<span class="w">   </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Considering the <code class="docutils literal notranslate"><span class="pre">Literal</span></code> node types first, we can follow a very similar process
to the previous section to extract the <code class="docutils literal notranslate"><span class="pre">value</span></code> field from the node giving us
enough information to fill out our first <code class="docutils literal notranslate"><span class="pre">AstNode</span></code> instance!</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">node</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AST_LITERAL</span><span class="p">;</span><span class="w"></span>
<span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"></span>
<span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="n">node</span><span class="o">-&gt;</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>As this node type has no children there’s no further work to do and we can
return successfully. However, in the case of <code class="docutils literal notranslate"><span class="pre">AST_PLUS</span></code> and <code class="docutils literal notranslate"><span class="pre">AST_MULTIPLY</span></code>
things aren’t as straightforward…</p>
</div>
<div class="section" id="traversing-the-tree">
<h3>Traversing the Tree<a class="headerlink" href="#traversing-the-tree" title="Permalink to this headline">¶</a></h3>
<p>Handling the other node types starts off easy enough, since  they are almost
identical we can handle their differences in the <code class="docutils literal notranslate"><span class="pre">switch</span></code> statement and then use
the remainder of the function to handle recursing down both the <code class="docutils literal notranslate"><span class="pre">left</span></code> and
<code class="docutils literal notranslate"><span class="pre">right</span></code> branches.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="nl">AST_PLUS</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AST_PLUS</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">case</span><span class="w"> </span><span class="nl">AST_MULTIPLY</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AST_MULTIPLY</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>We can then get references to the child nodes in the same way we’ve been
referencing all the other fields so far</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyObject_GetAttrString</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;left&quot;</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyObject_GetAttrString</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;right&quot;</span><span class="p">);</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Then “all” that is left to do is set the <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> pointers on the
<code class="docutils literal notranslate"><span class="pre">AstNode</span></code> struct and call <code class="docutils literal notranslate"><span class="pre">AstNode_FromPyObject</span></code> on each branch - remembering to
adjust the <code class="docutils literal notranslate"><span class="pre">index</span></code> value accordingly.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ast</span><span class="p">[</span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ast</span><span class="p">[</span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">AstNode_FromPyObject</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">ast</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">AstNode_FromPyObject</span><span class="p">(</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">ast</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>At least… that’s what I wanted to do initially, unfortunately this solution
wouldn’t work in practice,. If <code class="docutils literal notranslate"><span class="pre">left</span></code> is a reference to anything other than an
<code class="docutils literal notranslate"><span class="pre">AST_LITERAL</span></code> then it’s children would be overwritten when we start processing
nodes on the <code class="docutils literal notranslate"><span class="pre">right</span></code> branch!</p>
<p>This had me scratching my head for quite a while, trying to come up with a way
to compute the correct offset for the <code class="docutils literal notranslate"><span class="pre">right</span></code> branch - without success.</p>
<p>Instead, since this is C I ended up changing the <code class="docutils literal notranslate"><span class="pre">index</span></code> argument from an actual
<code class="docutils literal notranslate"><span class="pre">Py_ssize_t</span></code> to a pointer to one. This allows recursive calls to increment the
index as needed and by the time execution returns to the top level function, the
value referenced by the pointer is automatically the correct value.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">*</span><span class="n">index</span><span class="p">)</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ast</span><span class="p">[</span><span class="o">*</span><span class="n">index</span><span class="p">];</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">AstNode_FromPyObject</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">ast</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="p">(</span><span class="o">*</span><span class="n">index</span><span class="p">)</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ast</span><span class="p">[</span><span class="o">*</span><span class="n">index</span><span class="p">];</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">AstNode_FromPyObject</span><span class="p">(</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">ast</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>I have no idea if this is a terrible idea for real world scenarios, but it seems
to work well enough for this at least.</p>
<p>To complete the conversion code, all that remains is to make the initial call to
<code class="docutils literal notranslate"><span class="pre">AstNode_FromPyObject</span></code> from our main <code class="docutils literal notranslate"><span class="pre">AstTree_FromPyObject</span></code>  function</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">AstTree_FromPyObject</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">ast</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">index</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">free</span><span class="p">(</span><span class="n">ast</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">return</span><span class="w"> </span><span class="n">ast</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</div>
<div class="section" id="returning-the-result">
<span id="ast-python-frontend-return"></span><h3>Returning the Result<a class="headerlink" href="#returning-the-result" title="Permalink to this headline">¶</a></h3>
<p>Phew! That was a lot of work but we’re almost there. We just need to add a few
more lines to <code class="docutils literal notranslate"><span class="pre">method_eval_ast</span></code> that takes the newly constructed AST and
evaluates it, before converting the result into a Python float and returning it.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ast_evaluate</span><span class="p">(</span><span class="n">ast</span><span class="p">);</span><span class="w"></span>
<span class="n">free</span><span class="p">(</span><span class="n">ast</span><span class="p">);</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="n">PyFloat_FromDouble</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>That’s the C Extension finished, the only thing we could do is import the
<code class="docutils literal notranslate"><span class="pre">_ccalc</span></code> module from <code class="docutils literal notranslate"><span class="pre">ccalc</span></code> and expose the methods we want to present a unified
interface to users of the module.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># In ccalc/__init__.py</span>
<span class="kn">import</span> <span class="nn">_ccalc</span>

<span class="n">eval_ast</span> <span class="o">=</span> <span class="n">_ccalc</span><span class="o">.</span><span class="n">eval_ast</span>
</pre></div>
</div>
<p>And that way we can now make the example code from the start of this post
actually work!</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ccalc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expression</span> <span class="o">=</span> <span class="p">(</span><span class="n">ccalc</span><span class="o">.</span><span class="n">Literal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expression</span>
<span class="go">Multiply&lt;Plus&lt;Literal&lt;1.0&gt;, Literal&lt;2.0&gt;&gt;, Literal&lt;3.0&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ccalc</span><span class="o">.</span><span class="n">eval_ast</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
<span class="go">9.0</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="final-thoughts">
<h2>Final Thoughts<a class="headerlink" href="#final-thoughts" title="Permalink to this headline">¶</a></h2>
<p>There was a lot of code flying around in this post, if you want to see the final
result in its entirety you can find it</p>
<div class="section" id="best-practice">
<h3>Best Practice?<a class="headerlink" href="#best-practice" title="Permalink to this headline">¶</a></h3>
<p>This was my first CPython extension so I might be missing out on some best
practices, for example a question I had was around my use of <code class="docutils literal notranslate"><span class="pre">malloc</span></code> and
<code class="docutils literal notranslate"><span class="pre">free</span></code>. While writing this section I found the documentation on <a class="reference external" href="https://docs.python.org/3/c-api/memory.html">memory management</a>
and it appears that the recommendation is to use the <code class="docutils literal notranslate"><span class="pre">PyMem_*</span></code> family of
functions, even for allocations that are not <code class="docutils literal notranslate"><span class="pre">PyObjects</span></code>. However it looks
like there is a learning curve to these as some functions require holding
the <a class="reference external" href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock">GIL</a> and some don’t.</p>
<p>Hmm… speaking of the GIL, should this extension be acquiring it at any point?
🤔</p>
</div>
<div class="section" id="another-approach">
<h3>Another approach<a class="headerlink" href="#another-approach" title="Permalink to this headline">¶</a></h3>
<p>Another note worth mentioning is that it looks like it’s possible to
<a class="reference external" href="https://docs.python.org/3/extending/newtypes_tutorial.html">define custom types</a> directly in C. This means it should be possible to extend
the <code class="docutils literal notranslate"><span class="pre">AstNode</span></code> C struct to be an object than can be manipulated directly from
Python code - bypassing the need for all the conversion code we had to write.</p>
<p>However, I decided against this approach mainly because the “convert between the
representations” approach means we get to evolve the Python and C
representations semi independently. Assuming that the Python representation
exposes the correct fields then any method of generating the AST from Python is
perfectly valid.</p>
<p>Anyway, I think this post has gone on long enough I hope you found it useful and
I’ll see you in the next one!</p>
</div>
</div>
</div>

</article>




<div class="mt-8 pt-4 border-t">
    <script src="https://giscus.app/client.js"
            data-repo="alcarney/blog"
            data-repo-id="MDEwOlJlcG9zaXRvcnk2Njk3NzM3MQ=="
            data-category="Comments"
            data-category-id="DIC_kwDOA_3-W84B_XOl"
            data-mapping="pathname"
            data-reactions-enabled="1"
            data-emit-metadata="0"
            data-theme="light"
            crossorigin="anonymous"
            async>
    </script>
</div>



                </div>
            </div>

            <footer class="p-2 mt-8 mb-2 text-sm text-gray-600 border-t">
                <div class="flex flex-col justify-between max-w-3xl mx-auto lg:flex-row">
                    <span>
                        <a class="text-green-600" href="../../../_sources/blog/2021/ast-python-frontend.rst.txt" rel="nofollow">
                            Page Source
                        </a>
                    </span>
                    <span>Built with <a class="text-green-600" href="https://www.sphinx-doc.org/en/master/">Sphinx</a> v4.2.0</span>
                    <span>&#169; Copyright 2021, Alex Carney.</span>
                </div>
            </footer>
        </main>
        
    </div>
<script src="/_static/js/theme.js"></script>


  </body>
</html>